# 2024 November 28
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# TESTRUNNER: slow
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
source $testdir/lock_common.tcl
source $testdir/malloc_common.tcl
source $testdir/wal_common.tcl

set testprefix wal2big2
ifcapable !wal {finish_test ; return }

do_execsql_test 1.0 {
  PRAGMA journal_mode = wal2;
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
  CREATE INDEX i1 ON t1(b);

  PRAGMA wal_autocheckpoint = 0;
  PRAGMA journal_size_limit = 100000;
  PRAGMA synchronous = off;
} {wal2 0 100000}

do_execsql_test 1.1 {
  INSERT INTO t1 VALUES(1, 'one');
}

do_test 1.2 {
  list [file size test.db-wal] [file size test.db-wal2]
} {6320 0}

do_execsql_test 1.3 {
  PRAGMA wal_checkpoint;
  INSERT INTO t1 VALUES(2, 'two');
} {0 6 0}

do_test 1.4 {
  list [file size test.db-wal] [file size test.db-wal2]
} {8416 0}

proc hexrandomblob {n} {
  for {set j 0} {$j < $n} {incr j 2} {
    append ret [format "%02X" [expr {int(rand() * 256)}]]
  }
  return $ret
}
db func hexrandomblob hexrandomblob

expr srand(0)
do_test 1.5 {
  for {set ii 3} {$ii < 100} {incr ii} {
    execsql {
      INSERT INTO t1 VALUES($ii, hexrandomblob(80));
    }
  }
  list [file size test.db-wal] [file size test.db-wal2]
} {101688 224304}

do_execsql_test 1.6 {
  PRAGMA integrity_check;
} {ok}

do_execsql_test 1.7 {
  PRAGMA wal_checkpoint = RESTART;
} {0 311 97}

do_execsql_test 1.8 {
  PRAGMA integrity_check;
} {ok}

sqlite3 db2 test.db

do_execsql_test -db db2 1.9 {
  PRAGMA integrity_check;
} {ok}

do_execsql_test 1.10 {
  PRAGMA journal_size_limit = 10000000;
} {10000000}

do_test 1.11 {
  for {set ii 0} {$ii < 8000} {incr ii} {
    execsql {
      INSERT INTO t1 VALUES(nULL, hex(randomblob(40)));
    }
  }
  list [expr [file size test.db-wal]>10000000] \
       [expr [file size test.db-wal2]>10000000] \
} {1 1}

do_execsql_test -db db2 1.12 {
  PRAGMA integrity_check;
} {ok}

do_test 1.13 {
  db eval { PRAGMA wal_checkpoint = RESTART }
  set {} {}
} {}

do_execsql_test -db db2 1.14 {
  PRAGMA integrity_check;
} {ok}

do_execsql_test 1.15 {
  INSERT INTO t1 VALUES(nULL, hex(randomblob(40)));
}

#-------------------------------------------------------------------------
do_multiclient_test tn {
  do_test 1.$tn.0 {
    sql1 {
      CREATE TABLE t1(a, b);
      INSERT INTO t1 VALUES('A', 'B');
      CREATE INDEX i1 ON t1(a, b);
      PRAGMA journal_mode = wal2;
      PRAGMA journal_size_limit = 100000;
    }
  } {wal2 100000}

  do_test 1.$tn.1 {
    sql2 {
      PRAGMA cache_size = 5;
    }
  } {}

  do_test 1.$tn.2 {
    for {set ii 0} {$ii < 500} {incr ii} {
      sql1 {
        INSERT INTO t1 VALUES(hex(randomblob(20)), hex(randomblob(20)));
      }
    }
  } {}

  do_test 1.$tn.3 {
    list [expr [file size test.db-wal]>100000] \
         [expr [file size test.db-wal2]>100000]
  } {1 1}
  
  do_test 1.$tn.4 {
    sql2 {
      BEGIN;
        PRAGMA integrity_check;
    }
  } {ok}

  do_test 1.$tn.5 {
    sql1 { PRAGMA wal_checkpoint = RESTART; }
    set {} {}
  } {}

  do_test 1.$tn.6 {
    sql2 {
        PRAGMA integrity_check;
      COMMIT;
    }
  } {ok}

  do_test 1.$tn.7 {
    sql1 {
      INSERT INTO t1 VALUES(hex(randomblob(20)), hex(randomblob(20)));
    }
    code1 {
      set ::n_handler 0
      proc handler {nTry} {
        incr ::n_handler
        if {$nTry>10} {
          sql2 {
            COMMIT;
            BEGIN;
            PRAGMA integrity_check;
          }
        }
        return 0
      }
      db busy handler
    }
  } {}

  do_test 1.$tn.8 {
    sql2 {
      BEGIN;
        PRAGMA integrity_check;
    }
  } {ok}

  do_test 1.$tn.9 {
    sql1 {
      PRAGMA wal_checkpoint = RESTART;
    }
    code1 { set ::n_handler }
  } {12}

  do_test 1.$tn.10 {
    sql2 COMMIT
  } {}
}

finish_test

