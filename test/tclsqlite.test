# 2001 September 15
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for TCL interface to the
# SQLite library. 
#
# Actually, all tests are based on the TCL interface, so the main
# interface is pretty well tested.  This file contains some addition
# tests for fringe issues that the main test suite does not cover.
#
# $Id: tclsqlite.test,v 1.73 2009/03/16 13:19:36 danielk1977 Exp $

catch {sqlite3}

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix tcl

# Check the error messages generated by tclsqlite
#
set r "sqlite_orig HANDLE ?FILENAME? ?-vfs VFSNAME? ?-readonly BOOLEAN? ?-create BOOLEAN? ?-nofollow BOOLEAN? ?-nomutex BOOLEAN? ?-fullmutex BOOLEAN? ?-uri BOOLEAN?"
if {[sqlite3 -has-codec]} {
  append r " ?-key CODECKEY?"
}
do_test tcl-1.1 {
  set v [catch {sqlite3 -bogus} msg]
  regsub {really_sqlite3} $msg {sqlite3} msg
  lappend v $msg
} [list 1 "wrong # args: should be \"$r\""]
do_test tcl-1.1.1 {
  set v [catch {sqlite3} msg]
  regsub {really_sqlite3} $msg {sqlite3} msg
  lappend v $msg
} [list 1 "wrong # args: should be \"$r\""]
do_test tcl-1.2 {
  set v [catch {db bogus} msg]
  lappend v $msg
} {1 {bad option "bogus": must be authorizer, backup, bind_fallback, busy, cache, changes, close, collate, collation_needed, commit_hook, complete, config, copy, deserialize, enable_load_extension, errorcode, erroroffset, eval, exists, function, incrblob, interrupt, last_insert_rowid, nullvalue, onecolumn, preupdate, profile, progress, rekey, restore, rollback_hook, serialize, status, timeout, total_changes, trace, trace_v2, transaction, unlock_notify, update_hook, version, or wal_hook}}
do_test tcl-1.2.1 {
  set v [catch {db cache bogus} msg]
  lappend v $msg
} {1 {bad option "bogus": must be flush or size}}
do_test tcl-1.2.2 {
  set v [catch {db cache} msg]
  lappend v $msg
} {1 {wrong # args: should be "db cache option ?arg?"}}
do_test tcl-1.3 {
  execsql {CREATE TABLE t1(a int, b int)}
  execsql {INSERT INTO t1 VALUES(10,20)}
  set v [catch {
    db eval {SELECT * FROM t1} data {
      error "The error message"
    }
  } msg]
  lappend v $msg
} {1 {The error message}}
do_test tcl-1.4 {
  set v [catch {
    db eval {SELECT * FROM t2} data {
      error "The error message"
    }
  } msg]
  lappend v $msg
} {1 {no such table: t2}}
do_test tcl-1.5 {
  set v [catch {
    db eval {SELECT * FROM t1} data {
      break
    }
  } msg]
  lappend v $msg
} {0 {}}
catch {expr x*} msg
do_test tcl-1.6 {
  set v [catch {
    db eval {SELECT * FROM t1} data {
      expr x*
    }
  } msg]
  lappend v $msg
} [list 1 $msg]
do_test tcl-1.7 {
  set v [catch {db} msg]
  lappend v $msg
} {1 {wrong # args: should be "db SUBCOMMAND ..."}}
if {[catch {db auth {}}]==0} {
  do_test tcl-1.8 {
    set v [catch {db authorizer 1 2 3} msg]
    lappend v $msg
  } {1 {wrong # args: should be "db authorizer ?CALLBACK?"}}
}
do_test tcl-1.9 {
  set v [catch {db busy 1 2 3} msg]
  lappend v $msg
} {1 {wrong # args: should be "db busy CALLBACK"}}
do_test tcl-1.10 {
  set v [catch {db progress 1} msg]
  lappend v $msg
} {1 {wrong # args: should be "db progress N CALLBACK"}}
do_test tcl-1.11 {
  set v [catch {db changes xyz} msg]
  lappend v $msg
} {1 {wrong # args: should be "db changes "}}
do_test tcl-1.12 {
  set v [catch {db commit_hook a b c} msg]
  lappend v $msg
} {1 {wrong # args: should be "db commit_hook ?CALLBACK?"}}
ifcapable {complete} {
  do_test tcl-1.13 {
    set v [catch {db complete} msg]
    lappend v $msg
  } {1 {wrong # args: should be "db complete SQL"}}
}
do_test tcl-1.14 {
  set v [catch {db eval} msg]
  lappend v $msg
} {1 {wrong # args: should be "db eval ?OPTIONS? SQL ?ARRAY-NAME? ?SCRIPT?"}}
do_test tcl-1.15 {
  set v [catch {db function} msg]
  lappend v $msg
} {1 {wrong # args: should be "db function NAME ?SWITCHES? SCRIPT"}}
do_test tcl-1.16 {
  set v [catch {db last_insert_rowid xyz} msg]
  lappend v $msg
} {1 {wrong # args: should be "db last_insert_rowid "}}
do_test tcl-1.17 {
  set v [catch {db rekey} msg]
  lappend v $msg
} {1 {wrong # args: should be "db rekey KEY"}}
do_test tcl-1.18 {
  set v [catch {db timeout} msg]
  lappend v $msg
} {1 {wrong # args: should be "db timeout MILLISECONDS"}}
do_test tcl-1.19 {
  set v [catch {db collate} msg]
  lappend v $msg
} {1 {wrong # args: should be "db collate NAME SCRIPT"}}
do_test tcl-1.20 {
  set v [catch {db collation_needed} msg]
  lappend v $msg
} {1 {wrong # args: should be "db collation_needed SCRIPT"}}
do_test tcl-1.21 {
  set v [catch {db total_changes xyz} msg]
  lappend v $msg
} {1 {wrong # args: should be "db total_changes "}}
do_test tcl-1.22 {
  set v [catch {db copy} msg]
  lappend v $msg
} {1 {wrong # args: should be "db copy CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?"}}
do_test tcl-1.23 {
  set v [catch {sqlite3 db2 test.db -vfs nosuchvfs} msg]
  lappend v $msg
} {1 {no such vfs: nosuchvfs}}

catch {unset ::result}
do_test tcl-2.1 {
  execsql "CREATE TABLE t\u0123x(a int, b\u1235 float)"
} {}
ifcapable schema_pragmas {
  do_test tcl-2.2 {
    execsql "PRAGMA table_info(t\u0123x)"
  } "0 a INT 0 {} 0 1 b\u1235 float 0 {} 0"
}
do_test tcl-2.3 {
  execsql "INSERT INTO t\u0123x VALUES(1,2.3)"
  db eval "SELECT * FROM t\u0123x" result break
  set result(*)
} "a b\u1235"


# Test the onecolumn method
#
do_test tcl-3.1 {
  execsql {
    INSERT INTO t1 SELECT a*2, b*2 FROM t1;
    INSERT INTO t1 SELECT a*2+1, b*2+1 FROM t1;
    INSERT INTO t1 SELECT a*2+3, b*2+3 FROM t1;
  }
  set rc [catch {db onecolumn {SELECT * FROM t1 ORDER BY a}} msg]
  lappend rc $msg
} {0 10}
do_test tcl-3.2 {
  db onecolumn {SELECT * FROM t1 WHERE a<0}
} {}
do_test tcl-3.3 {
  set rc [catch {db onecolumn} errmsg]
  lappend rc $errmsg
} {1 {wrong # args: should be "db onecolumn SQL"}}
do_test tcl-3.4 {
  set rc [catch {db onecolumn {SELECT bogus}} errmsg]
  lappend rc $errmsg
} {1 {no such column: bogus}}
ifcapable {tclvar} {
  do_test tcl-3.5 {
    set b 50
    set rc [catch {db one {SELECT * FROM t1 WHERE b>$b}} msg]
    lappend rc $msg
  } {0 41}
  do_test tcl-3.6 {
    set b 500
    set rc [catch {db one {SELECT * FROM t1 WHERE b>$b}} msg]
    lappend rc $msg
  } {0 {}}
  do_test tcl-3.7 {
    set b 500
    set rc [catch {db one {
      INSERT INTO t1 VALUES(99,510);
      SELECT * FROM t1 WHERE b>$b
    }} msg]
    lappend rc $msg
  } {0 99}
}
ifcapable {!tclvar} {
   execsql {INSERT INTO t1 VALUES(99,510)}
}

# Turn the busy handler on and off
#
do_test tcl-4.1 {
  proc busy_callback {cnt} {
    break
  }
  db busy busy_callback
  db busy
} {busy_callback}
do_test tcl-4.2 {
  db busy {}
  db busy
} {}

ifcapable {tclvar} {
  # Parsing of TCL variable names within SQL into bound parameters.
  #
  do_test tcl-5.1 {
    execsql {CREATE TABLE t3(a,b,c)}
    catch {unset x}
    set x(1) A
    set x(2) B
    execsql {
      INSERT INTO t3 VALUES($::x(1),$::x(2),$::x(3));
      SELECT * FROM t3
    }
  } {A B {}}
  do_test tcl-5.2 {
    execsql {
      SELECT typeof(a), typeof(b), typeof(c) FROM t3
    }
  } {text text null}
  do_test tcl-5.3 {
    catch {unset x}
    set x [binary format h12 686900686f00]
    execsql {
      UPDATE t3 SET a=$::x;
    }
    db eval {
      SELECT a FROM t3
    } break
    binary scan $a h12 adata
    set adata
  } {686900686f00}
  do_test tcl-5.4 {
    execsql {
      SELECT typeof(a), typeof(b), typeof(c) FROM t3
    }
  } {blob text null}
}

# Operation of "break" and "continue" within row scripts
#
do_test tcl-6.1 {
  db eval {SELECT * FROM t1} {
    break
  }
  lappend a $b
} {10 20}
do_test tcl-6.2 {
  set cnt 0
  db eval {SELECT * FROM t1} {
    if {$a>40} continue
    incr cnt
  }
  set cnt
} {4}
do_test tcl-6.3 {
  set cnt 0
  db eval {SELECT * FROM t1} {
    if {$a<40} continue
    incr cnt
  }
  set cnt
} {5}
do_test tcl-6.4 {
  proc return_test {x} {
    db eval {SELECT * FROM t1} {
      if {$a==$x} {return $b}
    }
  }
  return_test 10
} 20
do_test tcl-6.5 {
  return_test 20
} 40
do_test tcl-6.6 {
  return_test 99
} 510
do_test tcl-6.7 {
  return_test 0
} {}

do_test tcl-7.1 {
  db version
  expr 0
} {0}

# modify and reset the NULL representation
#
do_test tcl-8.1 {
  db nullvalue NaN
  execsql {INSERT INTO t1 VALUES(30,NULL)}
  db eval {SELECT * FROM t1 WHERE b IS NULL}
} {30 NaN}
proc concatFunc args {return [join $args {}]}
do_test tcl-8.2 {
  db function concat concatFunc
  db eval {SELECT concat('a', b, 'z') FROM t1 WHERE b is NULL}
} {aNaNz}
do_test tcl-8.3 {
  db nullvalue NULL
  db nullvalue
} {NULL}
do_test tcl-8.4 {
  db nullvalue {}
  db eval {SELECT * FROM t1 WHERE b IS NULL}
} {30 {}}
do_test tcl-8.5 {
  db function concat concatFunc
  db eval {SELECT concat('a', b, 'z') FROM t1 WHERE b is NULL}
} {az}

# Test the return type of user-defined functions
#
do_test tcl-9.1 {
  db function ret_str {return "hi"}
  execsql {SELECT typeof(ret_str())}
} {text}
do_test tcl-9.2 {
  db function ret_dbl {return [expr {rand()*0.5}]}
  execsql {SELECT typeof(ret_dbl())}
} {real}
do_test tcl-9.3 {
  db function ret_int {return [expr {int(rand()*200)}]}
  execsql {SELECT typeof(ret_int())}
} {integer}

# Recursive calls to the same user-defined function
#
ifcapable tclvar {
  do_test tcl-9.10 {
    proc userfunc_r1 {n} {
      if {$n<=0} {return 0}
      set nm1 [expr {$n-1}]
      return [expr {[db eval {SELECT r1($nm1)}]+$n}]
    }
    db function r1 userfunc_r1
    execsql {SELECT r1(10)}
  } {55}
  # Fails under -fsanitize=address,undefined due to stack overflow
  # do_test tcl-9.11 {
  #   execsql {SELECT r1(100)}
  # } {5050}
}

# Tests for the new transaction method
#
do_test tcl-10.1 {
  db transaction {}
} {}
do_test tcl-10.2 {
  db transaction deferred {}
} {}
do_test tcl-10.3 {
  db transaction immediate {}
} {}
do_test tcl-10.4 {
  db transaction exclusive {}
} {}
do_test tcl-10.5 {
  set rc [catch {db transaction xyzzy {}} msg]
  lappend rc $msg
} {1 {bad transaction type "xyzzy": must be deferred, exclusive, or immediate}}
do_test tcl-10.6 {
  set rc [catch {db transaction {error test-error}} msg]
  lappend rc $msg
} {1 test-error}
do_test tcl-10.7 {
  db transaction {
    db eval {CREATE TABLE t4(x)}
    db transaction {
      db eval {INSERT INTO t4 VALUES(1)}
    }
  }
  db eval {SELECT * FROM t4}
} 1
do_test tcl-10.8 {
  catch {
    db transaction {
      db eval {INSERT INTO t4 VALUES(2)}
      db eval {INSERT INTO t4 VALUES(3)}
      db eval {INSERT INTO t4 VALUES(4)}
      error test-error
    }
  }
  db eval {SELECT * FROM t4}
} 1
do_test tcl-10.9 {
  db transaction {
    db eval {INSERT INTO t4 VALUES(2)}
    catch {
      db transaction {
        db eval {INSERT INTO t4 VALUES(3)}
        db eval {INSERT INTO t4 VALUES(4)}
        error test-error
      }
    }
  }
  db eval {SELECT * FROM t4}
} {1 2}
do_test tcl-10.10 {
  for {set i 0} {$i<1} {incr i} {
    db transaction {
      db eval {INSERT INTO t4 VALUES(5)}
      continue
    }
    error "This line should not be run"
  }
  db eval {SELECT * FROM t4}
} {1 2 5}
do_test tcl-10.11 {
  for {set i 0} {$i<10} {incr i} {
    db transaction {
      db eval {INSERT INTO t4 VALUES(6)}
      break
    }
  }
  db eval {SELECT * FROM t4}
} {1 2 5 6}
do_test tcl-10.12 {
  set rc [catch {
    for {set i 0} {$i<10} {incr i} {
      db transaction {
        db eval {INSERT INTO t4 VALUES(7)}
        return
      }
    }
  }]
} {2}
do_test tcl-10.13 {
  db eval {SELECT * FROM t4}
} {1 2 5 6 7}

# Now test that [db transaction] commands may be nested with 
# the expected results.
#
do_test tcl-10.14 {
  db transaction {
    db eval {
      DELETE FROM t4;
      INSERT INTO t4 VALUES('one');
    }

    catch { 
      db transaction {
        db eval { INSERT INTO t4 VALUES('two') }
        db transaction {
          db eval { INSERT INTO t4 VALUES('three') }
          error "throw an error!"
        }
      }
    }
  }

  db eval {SELECT * FROM t4}
} {one}
do_test tcl-10.15 {
  # Make sure a transaction has not been left open.
  db eval {BEGIN ; COMMIT}
} {}
do_test tcl-10.16 {
  db transaction {
    db eval { INSERT INTO t4 VALUES('two'); }
    db transaction {
      db eval { INSERT INTO t4 VALUES('three') }
      db transaction {
        db eval { INSERT INTO t4 VALUES('four') }
      }
    }
  }
  db eval {SELECT * FROM t4}
} {one two three four}
do_test tcl-10.17 {
  catch {
    db transaction {
      db eval { INSERT INTO t4 VALUES('A'); }
      db transaction {
        db eval { INSERT INTO t4 VALUES('B') }
        db transaction {
          db eval { INSERT INTO t4 VALUES('C') }
          error "throw an error!"
        }
      }
    }
  }
  db eval {SELECT * FROM t4}
} {one two three four}
do_test tcl-10.18 {
  # Make sure a transaction has not been left open.
  db eval {BEGIN ; COMMIT}
} {}

# Mess up a [db transaction] command by locking the database using a
# second connection when it tries to commit. Make sure the transaction
# is not still open after the "database is locked" exception is thrown.
#
do_test tcl-10.18 {
  sqlite3 db2 test.db
  db2 eval {
    BEGIN;
    SELECT * FROM sqlite_master;
  }

  set rc [catch {
    db transaction {
      db eval {INSERT INTO t4 VALUES('five')}
    }
  } msg]
  list $rc $msg
} {1 {database is locked}}
do_test tcl-10.19 {
  db eval {BEGIN ; COMMIT}
} {}

# Thwart a [db transaction] command by locking the database using a
# second connection with "BEGIN EXCLUSIVE". Make sure no transaction is 
# open after the "database is locked" exception is thrown.
#
do_test tcl-10.20 {
  db2 eval {
    COMMIT;
    BEGIN EXCLUSIVE;
  }
  set rc [catch {
    db transaction {
      db eval {INSERT INTO t4 VALUES('five')}
    }
  } msg]
  list $rc $msg
} {1 {database is locked}}
do_test tcl-10.21 {
  db2 close
  db eval {BEGIN ; COMMIT}
} {}
do_test tcl-10.22 {
  sqlite3 db2 test.db
  db transaction exclusive {
    catch { db2 eval {SELECT * FROM sqlite_master} } msg
    set msg "db2: $msg"
  }
  set msg
} {db2: database is locked}
db2 close

do_test tcl-11.1 {
  db eval {INSERT INTO t4 VALUES(6)}
  db exists {SELECT x,x*2,x+x FROM t4 WHERE x==6}
} {1}
do_test tcl-11.2 {
  db exists {SELECT 0 FROM t4 WHERE x==6}
} {1}
do_test tcl-11.3 {
  db exists {SELECT 1 FROM t4 WHERE x==8}
} {0}
do_test tcl-11.3.1 {
  tcl_objproc db exists {SELECT 1 FROM t4 WHERE x==8}
} {0}

do_test tcl-12.1 {
  unset -nocomplain a b c version
  set version [db version]
  scan $version "%d.%d.%d" a b c
  expr $a*1000000 + $b*1000 + $c
} [sqlite3_libversion_number]


# Check to see that when bindings of the form @aaa are used instead
# of $aaa, that objects are treated as bytearray and are inserted
# as BLOBs.
#
ifcapable tclvar {
  do_test tcl-13.1 {
    db eval {CREATE TABLE t5(x BLOB)}
    set x abc123
    db eval {INSERT INTO t5 VALUES($x)}
    db eval {SELECT typeof(x) FROM t5}
  } {text}
  do_test tcl-13.2 {
    binary scan $x H notUsed
    db eval {
      DELETE FROM t5;
      INSERT INTO t5 VALUES($x);
      SELECT typeof(x) FROM t5;
    }
  } {text}
  do_test tcl-13.3 {
    db eval {
      DELETE FROM t5;
      INSERT INTO t5 VALUES(@x);
      SELECT typeof(x) FROM t5;
    }
  } {blob}
  do_test tcl-13.4 {
    set y 1234
    db eval {
      DELETE FROM t5;
      INSERT INTO t5 VALUES(@y);
      SELECT hex(x), typeof(x) FROM t5
    }
  } {31323334 blob}
}

db func xCall xCall
proc xCall {} { return "value" }
do_execsql_test tcl-14.1 {
  CREATE TABLE t6(x);
  INSERT INTO t6 VALUES(1);
}
do_test tcl-14.2 {
  db one {SELECT x FROM t6 WHERE xCall()!='value'}
} {}

# Verify that the "exists" and "onecolumn" methods work when
# a "profile" is registered.
#
catch {db close}
sqlite3 db :memory:
proc noop-profile {args} {
  return
}
do_test tcl-15.0 {
  db eval {CREATE TABLE t1(a); INSERT INTO t1 VALUES(1),(2),(3);}
  db onecolumn {SELECT a FROM t1 WHERE a>2}
} {3}
do_test tcl-15.1 {
  db exists {SELECT a FROM t1 WHERE a>2}
} {1}
do_test tcl-15.2 {
  db exists {SELECT a FROM t1 WHERE a>3}
} {0}
db profile noop-profile
do_test tcl-15.3 {
  db onecolumn {SELECT a FROM t1 WHERE a>2}
} {3}
do_test tcl-15.4 {
  db exists {SELECT a FROM t1 WHERE a>2}
} {1}
do_test tcl-15.5 {
  db exists {SELECT a FROM t1 WHERE a>3}
} {0}


# 2017-06-26: The --withoutnulls flag to "db eval".
#
# In the "db eval --withoutnulls SQL ARRAY" form, NULL results cause the
# corresponding array entry to be unset.  The default behavior (without
# the -withoutnulls flags) is for the corresponding array value to get
# the [db nullvalue] string.
#
catch {db close}
forcedelete test.db
sqlite3 db test.db
do_execsql_test tcl-16.100 {
  CREATE TABLE t1(a,b);
  INSERT INTO t1 VALUES(1,2),(2,NULL),(3,'xyz');
}
do_test tcl-16.101 {
  set res {}
  unset -nocomplain x
  db eval {SELECT * FROM t1} x {
    lappend res $x(a) [array names x]
  }
  set res
} {1 {a b *} 2 {a b *} 3 {a b *}}
do_test tcl-16.102 {
  set res [catch {
    db eval -unknown {SELECT * FROM t1} x {
      lappend res $x(a) [array names x]
    }
  } rc]
  lappend res $rc
} {1 {unknown option: "-unknown"}}
do_test tcl-16.103 {
  set res {}
  unset -nocomplain x
  db eval -withoutnulls {SELECT * FROM t1} x {
    lappend res $x(a) [array names x]
  }
  set res
} {1 {a b *} 2 {a *} 3 {a b *}}

#-------------------------------------------------------------------------
# Test the -type option to [db function].
#
reset_db
proc add {a b} { return [expr $a + $b] }
proc ret {a} { return $a }

db function add_i -returntype integer add 
db function add_r -ret        real    add
db function add_t -return     text    add 
db function add_b -returntype blob    add 
db function add_a -returntype any     add 

db function ret_i -returntype int     ret 
db function ret_r -returntype real    ret
db function ret_t -returntype text    ret 
db function ret_b -returntype blob    ret 
db function ret_a -r          any     ret 

do_execsql_test 17.0 {
  SELECT quote( add_i(2, 3) );
  SELECT quote( add_r(2, 3) ); 
  SELECT quote( add_t(2, 3) ); 
  SELECT quote( add_b(2, 3) ); 
  SELECT quote( add_a(2, 3) ); 
} {5 5.0 '5' X'35' 5}

do_execsql_test 17.1 {
  SELECT quote( add_i(2.2, 3.3) );
  SELECT quote( add_r(2.2, 3.3) ); 
  SELECT quote( add_t(2.2, 3.3) ); 
  SELECT quote( add_b(2.2, 3.3) ); 
  SELECT quote( add_a(2.2, 3.3) ); 
} {5.5 5.5 '5.5' X'352E35' 5.5}

do_execsql_test 17.2 {
  SELECT quote( ret_i(2.5) );
  SELECT quote( ret_r(2.5) ); 
  SELECT quote( ret_t(2.5) ); 
  SELECT quote( ret_b(2.5) ); 
  SELECT quote( ret_a(2.5) ); 
} {2.5 2.5 '2.5' X'322E35' 2.5}

do_execsql_test 17.3 {
  SELECT quote( ret_i('2.5') );
  SELECT quote( ret_r('2.5') ); 
  SELECT quote( ret_t('2.5') ); 
  SELECT quote( ret_b('2.5') ); 
  SELECT quote( ret_a('2.5') ); 
} {2.5 2.5 '2.5' X'322E35' '2.5'}

do_execsql_test 17.4 {
  SELECT quote( ret_i('abc') );
  SELECT quote( ret_r('abc') ); 
  SELECT quote( ret_t('abc') ); 
  SELECT quote( ret_b('abc') ); 
  SELECT quote( ret_a('abc') ); 
} {'abc' 'abc' 'abc' X'616263' 'abc'}

do_execsql_test 17.5 {
  SELECT quote( ret_i(X'616263') );
  SELECT quote( ret_r(X'616263') ); 
  SELECT quote( ret_t(X'616263') ); 
  SELECT quote( ret_b(X'616263') ); 
  SELECT quote( ret_a(X'616263') ); 
} {'abc' 'abc' 'abc' X'616263' X'616263'}

do_test 17.6.1 {
  list [catch { db function xyz -return object ret } msg] $msg
} {1 {bad type "object": must be integer, real, text, blob, or any}}

do_test 17.6.2 {
  list [catch { db function xyz -return ret } msg] $msg
} {1 {option requires an argument: -return}}

do_test 17.6.3 {
  list [catch { db function xyz -n object ret } msg] $msg
} {1 {bad option "-n": must be -argcount, -deterministic, -directonly, -innocuous, or -returntype}}

# 2019-02-28: The "bind_fallback" command.
#
do_test 18.100 {
  unset -nocomplain bindings abc def ghi jkl mno e01 e02
  set bindings(abc) [expr {1+2}]
  set bindings(def) {hello}
  set bindings(ghi) [expr {3.1415926*1.0}]
  proc bind_callback {nm} {
    global bindings
    set n2 [string range $nm 1 end]
    if {[info exists bindings($n2)]} {
      return $bindings($n2)
    }
    if {[string match e* $n2]} {
      error "no such variable: $nm"
    }
    return -code return {}
  }
  db bind_fallback bind_callback
  db eval {SELECT $abc, typeof($abc), $def, typeof($def), $ghi, typeof($ghi)}
} {3 integer hello text 3.1415926 real}
do_test 18.110 {
  db eval {SELECT quote(@def), typeof(@def)}
} {X'68656C6C6F' blob}
do_execsql_test 18.120 {
  SELECT typeof($mno);
} {null}
do_catchsql_test 18.130 {
  SELECT $e01;
} {1 {no such variable: $e01}}
do_test 18.140 {
  db bind_fallback
} {bind_callback}
do_test 18.200 {
  db bind_fallback {}
  db eval {SELECT $abc, typeof($abc), $def, typeof($def), $ghi, typeof($ghi)}
} {{} null {} null {} null}
do_test 18.300 {
  unset -nocomplain bindings
  proc bind_callback {nm} {lappend ::bindings $nm}
  db bind_fallback bind_callback
  db eval {SELECT $abc, @def, $ghi(123), :mno}
  set bindings
} {{$abc} @def {$ghi(123)} :mno}
do_test 18.900 {
  set rc [catch {db bind_fallback a b} msg]
  lappend rc $msg
} {1 {wrong # args: should be "db bind_fallback ?CALLBACK?"}}
do_test 18.910 {
  db bind_fallback bind_fallback_does_not_exist
} {}
do_catchsql_test 19.911 {
  SELECT $abc, typeof($abc), $def, typeof($def), $ghi, typeof($ghi);
} {1 {invalid command name "bind_fallback_does_not_exist"}}
db bind_fallback {}

#-------------------------------------------------------------------------
do_test 20.0 {
  db transaction {
    db close
  }
} {}

do_test 20.1 {
  sqlite3 db test.db
  set rc [catch {
    db eval {SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3} { db close }
  } msg]
  list $rc $msg
} {1 {invalid command name "db"}}
  

proc closedb {} {
  db close
  return 10
}
proc func1 {} { return 1 }

sqlite3 db test.db
db func closedb closedb
db func func1 func1

do_test 20.2 {
  set rc [catch {
    db eval {
      SELECT closedb(),func1() UNION ALL SELECT 20,30 UNION ALL SELECT 30,40
    }
  } msg]
  list $rc $msg
} {0 {10 1 20 30 30 40}}

sqlite3 db :memory:
do_test 21.1 {
  catch {db eval {SELECT 1 2 3;}} msg
  db erroroffset
} {9}

finish_test
