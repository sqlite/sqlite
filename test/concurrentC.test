# 2023 January 12
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
# This file implements regression tests for SQLite library.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix concurrentC

do_execsql_test 1.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(a PRIMARY KEY, b TEXT) WITHOUT ROWID;
  CREATE UNIQUE INDEX i1 ON t1(b);
} {wal}

sqlite3 db2 test.db

do_test 1.1 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(1, 'one');
      INSERT INTO t1 VALUES(3, 'three');
      INSERT INTO t1 VALUES(5, 'five');
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(2, 'two');
      INSERT INTO t1 VALUES(4, 'four');
      INSERT INTO t1 VALUES(6, 'six');
    COMMIT;
  } db2
  execsql COMMIT
} {}

do_test 1.2 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(7, 'seven');
      INSERT INTO t1 VALUES(10, 'nine');
      INSERT INTO t1 VALUES(11, 'eleven');
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(8, 'eight');
      INSERT INTO t1 VALUES(10, 'ten');
      INSERT INTO t1 VALUES(12, 'twelve');
    COMMIT;
  } db2
  catchsql COMMIT
} {1 {database is locked}}
execsql ROLLBACK

do_test 1.3 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(13, 'thirteen');
      INSERT INTO t1 VALUES(15, 'sixteen');
      INSERT INTO t1 VALUES(17, 'seventeen');
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(14, 'fourteen');
      INSERT INTO t1 VALUES(16, 'sixteen');
      INSERT INTO t1 VALUES(18, 'eighteen');
    COMMIT;
  } db2
  catchsql COMMIT
} {1 {database is locked}}

db2 close


#-----------------------------------------------------------------
# Check that different databases use different shared-logs.
#
reset_db

forcedelete test.db2
forcedelete test.db3

sqlite3 db1 test.db
sqlite3 db2 test.db2
sqlite3 db3 test.db3

do_test 2.0 {
  execsql {
    PRAGMA journal_mode = wal;
    CREATE TABLE t1(a PRIMARY KEY, b TEXT) WITHOUT ROWID;
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES('a1', 'one');
  } db1
  execsql {
    PRAGMA journal_mode = wal;
    CREATE TABLE t1(a PRIMARY KEY, b TEXT) WITHOUT ROWID;
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES('a2', 'two');
  } db2
  execsql {
    PRAGMA journal_mode = wal;
    CREATE TABLE t1(a PRIMARY KEY, b TEXT) WITHOUT ROWID;
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES('a3', 'three');
  } db3
} {wal}

do_execsql_test 2.1 {
  ATTACH 'test.db2' AS 'd2';
  ATTACH 'test.db3' AS 'd3';
  BEGIN CONCURRENT;
    INSERT INTO t1 VALUES('a2', 'one.2');
    INSERT INTO d2.t1 VALUES('a1', 'two.2');
    INSERT INTO d3.t1 VALUES('a2', 'three.2');
}

do_test 2.2 {
  execsql COMMIT db1;
  execsql COMMIT db2;
  execsql COMMIT db3;
  execsql COMMIT
} {}

#---------------------------------------------------------------
#
reset_db
do_execsql_test 3.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(a REAL PRIMARY KEY, b TEXT) WITHOUT ROWID;
} {wal}

do_execsql_test 3.1 {
  BEGIN CONCURRENT;
    SELECT * FROM t1 WHERE a>35;
    SELECT * FROM sqlite_concurrent;
} {2 read (35)+ ()+}
execsql ROLLBACK

do_execsql_test 3.2 {
  BEGIN CONCURRENT;
    INSERT INTO t1 VALUES(zeroblob(16), 16);
    SELECT * FROM sqlite_concurrent WHERE op='insert';
} {2 insert (X'00000000000000000000000000000000','16') {}}
execsql ROLLBACK

#---------------------------------------------------------------
#
reset_db
proc joinup {txt n} {
  join [string repeat "[list $txt] " $n] ,
}
proc cols {n} {
  set ret [list]
  for {set i 0} {$i < $n} {incr i} {
    lappend ret "c$i"
  }
  join $ret ,
}

do_execsql_test 4.0 "
  PRAGMA journal_mode = wal;
  CREATE TABLE t1([cols 200]);
  CREATE INDEX i1 ON t1([cols 200]);

  INSERT INTO t1 VALUES( [joinup 10 200] );
  INSERT INTO t1 VALUES( [joinup 20 200] );
  INSERT INTO t1 VALUES( [joinup 30 200] );
  INSERT INTO t1 VALUES( [joinup 40 200] );
" {wal}

do_execsql_test 4.1 "
  BEGIN CONCURRENT;
    SELECT * FROM t1 WHERE ([cols 150]) = ([joinup 30 150]);
    SELECT * FROM sqlite_concurrent;
" "
  [string repeat {30 } 200]
  4 read ([joinup 30 150])- ([joinup 30 150])+
"
execsql ROLLBACK

do_execsql_test 4.1 "
  BEGIN CONCURRENT;
    SELECT * FROM t1 WHERE ([cols 127]) = ([joinup 30 127]);
    SELECT * FROM sqlite_concurrent;
" "
  [string repeat {30 } 200]
  4 read ([joinup 30 127])- ([joinup 30 127])+
"
execsql ROLLBACK

#---------------------------------------------------------------
# Tests for zeroblob().
#
reset_db
do_execsql_test 5.0 {
  PRAGMA journal_mode = wal2;
  CREATE TABLE t1(x INTEGER PRIMARY KEY, y);
  CREATE INDEX i1 ON t1(y);
} {wal2}

sqlite3 db2 test.db

do_test 5.1 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(10, zeroblob(500));
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(20, zeroblob(500));
    COMMIT;
  } db2
  execsql {
    COMMIT;
    SELECT count(*) FROM t1 WHERE y=zeroblob(500);
  }
} {2}

do_test 5.2 {
  execsql {
    BEGIN CONCURRENT;
      SELECT x FROM t1 WHERE y=zeroblob(500);
      INSERT INTO t1 VALUES(30, zeroblob(100));
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(40, zeroblob(500));
    COMMIT;
  } db2
  catchsql COMMIT

} {1 {database is locked}}
execsql ROLLBACK

do_test 5.3 {
  execsql {
    BEGIN CONCURRENT;
      SELECT x FROM t1 WHERE y=zeroblob(0);
      INSERT INTO t1 VALUES(50, zeroblob(100));
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(60, zeroblob(0));
    COMMIT;
  } db2
  catchsql COMMIT

} {1 {database is locked}}
execsql ROLLBACK
 
#---------------------------------------------------------------
#
reset_db
do_execsql_test 6.0 {
  PRAGMA journal_mode = wal2;
  CREATE TABLE t1(x INTEGER PRIMARY KEY, y);
  CREATE INDEX i1 ON t1(y);
} {wal2}

do_execsql_test 6.1 {
  BEGIN CONCURRENT;
    INSERT INTO t1 VALUES(1, 'xyz');
    SAVEPOINT one;
      SAVEPOINT two;
        CREATE TEMP TABLE t2(x);
    RELEASE one;
    INSERT INTO t1 VALUES(2, 'XYZ');
  COMMIT;
}

#---------------------------------------------------------------
#
reset_db
do_execsql_test 7.0 {
  PRAGMA journal_mode = wal2;
  CREATE TABLE t1(x INTEGER PRIMARY KEY, b UNIQUE);
  CREATE TABLE t2(x INTEGER PRIMARY KEY, b UNIQUE);
} {wal2}

sqlite3 db2 test.db

do_test 7.1 {
  execsql { BEGIN CONCURRENT }
  execsql { BEGIN CONCURRENT } db2
  for {set ii 0} {$ii < 1000} {incr ii 4} {
    execsql "INSERT INTO t1 VALUES($ii, $ii)"
    execsql "INSERT INTO t2 VALUES($ii, $ii)"
    execsql "INSERT INTO t1 VALUES([expr $ii+1], [expr $ii+1])" db2
    execsql "INSERT INTO t2 VALUES([expr $ii+1], [expr $ii+1])" db2
  }
  for {set ii 0} {$ii < 1000} {incr ii 4} {
    execsql "INSERT INTO t1 VALUES([expr $ii+2], [expr $ii+2])"
    execsql "INSERT INTO t2 VALUES([expr $ii+2], [expr $ii+2])"
    execsql "INSERT INTO t1 VALUES([expr $ii+3], [expr $ii+3])" db2
    execsql "INSERT INTO t2 VALUES([expr $ii+3], [expr $ii+3])" db2
  }

  execsql COMMIT
  execsql COMMIT db2
} {}

#-------------------------------------------------------------------------
# Check that deleting a record added by the same transaction causes
# no problems.
#
reset_db
do_execsql_test 8.0 {
  PRAGMA journal_mode = wal2;
  CREATE TABLE t1(x INTEGER PRIMARY KEY, y);
  CREATE TABLE t2(x INTEGER PRIMARY KEY, y) WITHOUT ROWID;
} {wal2}
sqlite3 db2 test.db

do_test 8.1 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(1, 'one');
      INSERT INTO t1 VALUES(3, 'three');
      INSERT INTO t1 VALUES(5, 'five');
      DELETE FROM t1 WHERE x=3;

      INSERT INTO t2 VALUES(1, 'one');
      INSERT INTO t2 VALUES(3, 'three');
      INSERT INTO t2 VALUES(5, 'five');
      DELETE FROM t2 WHERE x=3;
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(7, 'seven');
    COMMIT;
  } db2
  execsql COMMIT;
} {}

do_execsql_test 8.2 {
  SELECT * FROM t1;
  SELECT * FROM t2;
} {1 one 5 five 7 seven    1 one 5 five}

do_test 8.3 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(9, 'nine');
      DELETE FROM t2 WHERE x=1;
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(10, 'ten');
    COMMIT;
    INSERT INTO t1 VALUES(8, 'eight');
  } db2
  catchsql COMMIT;
} {1 {database is locked}}
execsql ROLLBACK

do_test 8.4 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(-1, 'minus one');
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t2 VALUES(-1, 'negative one');
    COMMIT;
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(-2, 'minustwo');
    COMMIT;
  } db2
  execsql COMMIT;
} {}

#---------------------------------------------------------------
#
# 9.1: Test that interwoven writes on WITHOUT ROWID tables work.
# 9.2: Test the same with 7 nested savepoints.
# 9.3: Test the same with 8 nested savepoints. This fails, because
#      the logical validation code gives up recording things if
#      that many savepoints are used.
# 9.4: Test the same with 32 nested savepoints. 
#

reset_db
do_execsql_test 9.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(a PRIMARY KEY, b TEXT) WITHOUT ROWID;
} {wal}

sqlite3 db2 test.db


do_test 9.1 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES('aa', 'ten');
      INSERT INTO t1 VALUES('ba', 'twenty');
      INSERT INTO t1 VALUES('ca', 'thirty');
  }

  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES('ab', 'one');
      INSERT INTO t1 VALUES('bb', 'two');
      INSERT INTO t1 VALUES('cb', 'three');
    COMMIT;
  } db2

  execsql {
    COMMIT
  }
} {}

do_test 9.2 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES('da', 'ten');
      INSERT INTO t1 VALUES('ea', 'twenty');
      INSERT INTO t1 VALUES('fa', 'thirty');
  }

  execsql {
    BEGIN CONCURRENT;
      SAVEPOINT a1;
        INSERT INTO t1 VALUES('db', 'one');
        INSERT INTO t1 VALUES('eb', 'two');
        SAVEPOINT a2; SAVEPOINT a3; SAVEPOINT a4; SAVEPOINT a5; 
        SAVEPOINT a6; SAVEPOINT a7; 
          INSERT INTO t1 VALUES('fb', 'three');
    COMMIT;
  } db2

  execsql {
    COMMIT
  }
} {}

do_test 9.3 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES('ga', 'ten');
      INSERT INTO t1 VALUES('ha', 'twenty');
      INSERT INTO t1 VALUES('ia', 'thirty');
  }

  execsql {
    BEGIN CONCURRENT;
      SAVEPOINT a1;
        INSERT INTO t1 VALUES('gb', 'one');
        INSERT INTO t1 VALUES('hb', 'two');
        SAVEPOINT a2; SAVEPOINT a3; SAVEPOINT a4; SAVEPOINT a5; 
        SAVEPOINT a6; SAVEPOINT a7; SAVEPOINT a8;
          INSERT INTO t1 VALUES('ib', 'three');
    COMMIT;
  } db2

  catchsql {
    COMMIT
  }
} {1 {database is locked}}
execsql ROLLBACK

do_test 9.4 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES('ja', 'ten');
      INSERT INTO t1 VALUES('ka', 'twenty');
      INSERT INTO t1 VALUES('la', 'thirty');
  }

  execsql {
    BEGIN CONCURRENT;
      SAVEPOINT a1;
        INSERT INTO t1 VALUES('jb', 'one');
        INSERT INTO t1 VALUES('kb', 'two');
        SAVEPOINT a2; SAVEPOINT a3; SAVEPOINT a4; SAVEPOINT a5; 
        SAVEPOINT a6; SAVEPOINT a7; SAVEPOINT a8; SAVEPOINT a9;
        SAVEPOINT a2; SAVEPOINT a3; SAVEPOINT a4; SAVEPOINT a5; 
        SAVEPOINT a6; SAVEPOINT a7; SAVEPOINT a8; SAVEPOINT a9;
        SAVEPOINT a2; SAVEPOINT a3; SAVEPOINT a4; SAVEPOINT a5; 
        SAVEPOINT a6; SAVEPOINT a7; SAVEPOINT a8; SAVEPOINT a9;
          INSERT INTO t1 VALUES('lb', 'three');
    COMMIT;
  } db2

  catchsql {
    COMMIT
  }
} {1 {database is locked}}

#-------------------------------------------------------------------------
#
reset_db
do_execsql_test 11.0 {
  PRAGMA journal_mode = wal2;
  PRAGMA journal_size_limit = 8192;
  PRAGMA wal_autocheckpoint = 0;
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
  CREATE TABLE t2(a INTEGER PRIMARY KEY, b);
  INSERT INTO t1 VALUES(1, 1);
  INSERT INTO t2 VALUES(1, 1);
  INSERT INTO t1 VALUES(2, 2);
  INSERT INTO t2 VALUES(2, 2);
  INSERT INTO t1 VALUES(3, 3);
  INSERT INTO t2 VALUES(3, 3);
} {wal2 8192 0}

do_test 11.1 {
  list [file size test.db-wal] [file size test.db-wal2]
} {8416 2128}

do_execsql_test 11.2 {
  PRAGMA wal_checkpoint;
  BEGIN CONCURRENT;
    INSERT INTO t2 VALUES(5, 5);
} {0 10 8}

sqlite3 db2 test.db

do_test 11.3 {
  execsql {
    PRAGMA journal_size_limit = 8192;
    BEGIN CONCURRENT; INSERT INTO t1 VALUES(4, 4); COMMIT;
    BEGIN CONCURRENT; INSERT INTO t1 VALUES(5, 5); COMMIT;
    BEGIN CONCURRENT; INSERT INTO t1 VALUES(6, 6); COMMIT;
    BEGIN CONCURRENT; INSERT INTO t1 VALUES(7, 7); COMMIT;
    BEGIN CONCURRENT; INSERT INTO t1 VALUES(8, 8); COMMIT;
    BEGIN CONCURRENT; INSERT INTO t1 VALUES(9, 9); COMMIT;
    BEGIN CONCURRENT; INSERT INTO t1 VALUES(10, 10); COMMIT;
    BEGIN CONCURRENT; INSERT INTO t1 VALUES(11, 11); COMMIT;
    BEGIN CONCURRENT; INSERT INTO t2 VALUES(4, 4); COMMIT;
  } db2
} {8192}

do_test 11.4 {
  list [file size test.db-wal] [file size test.db-wal2]
} {8416 8416}

do_execsql_test 11.5 COMMIT




finish_test


