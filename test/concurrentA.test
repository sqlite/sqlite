# 2023 January 12
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#*************************************************************************
# This file implements regression tests for SQLite library.
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix concurrentA

do_execsql_test 1.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(x INTEGER PRIMARY KEY, b);
  INSERT INTO t1 VALUES(1, 'one');
  INSERT INTO t1 VALUES(2, 'two');
  INSERT INTO t1 VALUES(3, 'three');
  INSERT INTO t1 VALUES(4, 'four');
  INSERT INTO t1 VALUES(5, 'five');
} {wal}

do_execsql_test 1.1 {
  BEGIN CONCURRENT;
    SELECT * FROM t1 WHERE x=4;
} {4 four}

do_execsql_test 1.2 {
    INSERT INTO t1 VALUES(6, 'six');
}

do_execsql_test 1.3 {
  SELECT * FROM sqlite_concurrent;
} {
  2 read   4  4
  2 read   6  6
  2 insert 6 (NULL,'six')
}

do_execsql_test 1.4 {
  COMMIT;
}

do_execsql_test 2.0 {
  BEGIN CONCURRENT;
    UPDATE t1 SET b='four+1' WHERE x=4;
    DELETE FROM t1 WHERE x=1;
}

sqlite3 db2 test.db
do_execsql_test -db db2 2.1 {
  BEGIN CONCURRENT;
    UPDATE t1 SET b='two+1' WHERE x=2;
  COMMIT;
}

do_execsql_test 2.2 {
  COMMIT;
  SELECT * FROM t1;
} {
  2 two+1 3 three 4 four+1 5 five 6 six
}

do_execsql_test 2.3 {
  BEGIN CONCURRENT;
    UPDATE t1 SET b='three+1' WHERE x=3;
    SELECT * FROM t1 WHERE x=6;
} {6 six}

do_execsql_test -db db2 2.4 {
  BEGIN CONCURRENT;
    UPDATE t1 SET b='six+1' WHERE x=6;
  COMMIT;
}

do_catchsql_test 2.5 {
  COMMIT
} {1 {database is locked}}

#--------------------------------------------------------------------------
reset_db

do_execsql_test 3.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(x INTEGER PRIMARY KEY, b);
  INSERT INTO t1 VALUES(2, 'two');
  INSERT INTO t1 VALUES(4, 'four');
  INSERT INTO t1 VALUES(6, 'six');
  INSERT INTO t1 VALUES(8, 'eight');
  INSERT INTO t1 VALUES(10, 'ten');
  INSERT INTO t1 VALUES(12, 'twelve');
  INSERT INTO t1 VALUES(14, 'fourteen');
  INSERT INTO t1 VALUES(16, 'sixteen');
  INSERT INTO t1 VALUES(18, 'eightteen');
  INSERT INTO t1 VALUES(20, 'twenty');
} {wal}

set START -9223372036854775808
set END    9223372036854775807
foreach {tn sql range} {
  1 { SELECT * FROM t1 }                         {$START $END}
  2 { SELECT * FROM t1 WHERE x BETWEEN 4 AND 8 } {4 10}
  3 { SELECT * FROM t1 WHERE x BETWEEN 4 AND 7 } {4 8}
  4 { SELECT * FROM t1 WHERE x = 4 }             {4 4}
  5 { SELECT * FROM t1 WHERE x = 5 }             {5 5}
  6 { SELECT * FROM t1 WHERE x > 6 }             {6 $END}
  7 { SELECT * FROM t1 WHERE x > 5 }             {5 $END}
  8 { SELECT max(x) FROM t1 }                    {20 $END}
  9 { SELECT min(x) FROM t1 }                    {$START 2}
  10 { INSERT INTO t1 VALUES(NULL, NULL) }       {20 $END 21 21}
  11 { SELECT * FROM t1 WHERE x < 6 ORDER BY x DESC} {$START 6}
} {

  set lRes [list]
  foreach {a b} [subst $range] { lappend lRes 2 read $a $b }

  execsql "BEGIN CONCURRENT"
  execsql $sql
  do_execsql_test 3.1.$tn {
    SELECT * FROM sqlite_concurrent WHERE op='read'
  } $lRes

  execsql ROLLBACK
}

db close
sqlite3 db test.db
sqlite3 db2 test.db

do_test 3.2 {
  execsql {
    BEGIN CONCURRENT;
      UPDATE t1 SET b='six+1' WHERE x=6;
    COMMIT;
  }
  execsql {
    BEGIN CONCURRENT;
      UPDATE t1 SET b='ten+1' WHERE x=10;
      SELECT * FROM t1 WHERE x=6;
  } 
  execsql {
    BEGIN CONCURRENT;
      UPDATE t1 SET b='sixteen+1' WHERE x=16;
    COMMIT;
  } db2
  execsql {
    COMMIT
  }
} {}
do_test 3.3 {
  execsql {
    BEGIN CONCURRENT;
      UPDATE t1 SET b='four+1' WHERE x=4;
  }
  execsql {
    UPDATE t1 SET b='four+2' WHERE x=4;
  } db2
  catchsql {
    COMMIT
  }
} {1 {database is locked}}
execsql { ROLLBACK }

do_test 3.4 {
  execsql {
    BEGIN CONCURRENT;
      UPDATE t1 SET b='four+3' WHERE x=4;
  }
  execsql {
    BEGIN CONCURRENT;
      UPDATE t1 SET b='four+4' WHERE x=4;
    COMMIT;
  } db2
  catchsql {
    COMMIT
  }
} {1 {database is locked}}
execsql { ROLLBACK }

#-------------------------------------------------------------------------
reset_db
do_execsql_test 4.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(x INTEGER PRIMARY KEY, y INTEGER);
  INSERT INTO t1 VALUES(1, 10), (2, 20), (3, 30), (4, 40), (5, 50);
  INSERT INTO t1 VALUES(6, 60), (7, 70), (8, 80), (9, 90), (10, 100);
  CREATE INDEX i1 ON t1(y);
} {wal}

foreach {tn sql idx} {
  1 "SELECT * FROM t1 WHERE y=50" {(50)- (50)+}
  2 "SELECT * FROM t1 WHERE y<50" {(NULL)+ (50,5)}

  3 "SELECT * FROM t1 WHERE y>50" {(50)+ ()+}
  4 "SELECT * FROM t1 WHERE y>=50" {(50)- ()+}

  4 "SELECT * FROM t1 WHERE y<50 ORDER BY y DESC" {()- (50)-}


  5 "SELECT * FROM t1 WHERE y>50" {(50)+ ()+}

} {

  execsql "BEGIN CONCURRENT"
  execsql $sql

  set lRes [list]
  foreach {a b} $idx {
    lappend lRes 3 read $a $b
  }
    
  do_execsql_test 4.1.$tn {
    SELECT * FROM sqlite_concurrent WHERE op='read' 
  } $lRes


  execsql ROLLBACK
}

#-------------------------------------------------------------------------
reset_db 
do_execsql_test 5.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b UNIQUE);
  BEGIN CONCURRENT;
    INSERT INTO t1 VALUES(1, 'one');
    INSERT INTO t1 VALUES(2, 'two');
  COMMIT;
} {wal}

#-------------------------------------------------------------------------
reset_db 
do_execsql_test 6.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
  CREATE TABLE t2(x);
  INSERT INTO t1 VALUES
    (1, 1), (2, 1), (3, 1), (4, 1),
    (5, 2), (6, 2), (7, 2), (8, 2),
    (9, 3), (10, 3), (11, 3), (12, 3);
  CREATE INDEX i1 ON t1(b);
} {wal}

sqlite3 db2 test.db

do_execsql_test 6.1.1 {
  BEGIN CONCURRENT;
    SELECT a FROM t1 WHERE b=1;
    INSERT INTO t2 VALUES('hello');
} {1 2 3 4}

do_test 6.1.2 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(13, 1);
    COMMIT;
  } db2
} {}

do_catchsql_test 6.1.3 {
  COMMIT
} {1 {database is locked}}
execsql ROLLBACK

do_execsql_test 6.2.1 {
  BEGIN CONCURRENT;
    SELECT count(*) FROM t1;
    INSERT INTO t2 VALUES('world');
} {13}

do_test 6.2.2 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(14, 4);
    COMMIT;
  } db2
} {}

do_catchsql_test 6.2.3 {
  COMMIT
} {1 {database is locked}}
execsql ROLLBACK

#-------------------------------------------------------------------------
#
reset_db 
do_execsql_test 7.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(x, y);
  CREATE TABLE t2(a INTEGER PRIMARY KEY, b);
  INSERT INTO t2 VALUES(1, 'one');
  INSERT INTO t2 VALUES(2, 'two');
  INSERT INTO t2 VALUES(3, 'three');
} {wal}

do_execsql_test 7.1.1 {
  BEGIN CONCURRENT;
    UPDATE t2 SET b='one+1' WHERE a=1;
    SAVEPOINT rb;
      INSERT INTO t1 VALUES(1, 2);
    ROLLBACK TO rb;
}

sqlite3 db2 test.db

do_test 7.1.2 {
  execsql {
    BEGIN CONCURRENT;
      UPDATE t2 SET b='three+1' WHERE a=3;
    COMMIT;
  } db2
} {}

do_execsql_test 7.1.3 {
  COMMIT;
  SELECT * FROM t1;
} {}

#-------------------------------------------------------------------------
reset_db
do_execsql_test 8.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE x1(a INTEGER PRIMARY KEY, b, c, d);
  CREATE INDEX i1 ON x1(b, c, d);
  CREATE INDEX i2 ON x1(d DESC);

  WITH dval(x) AS (
    SELECT 10 UNION ALL SELECT 20 UNION ALL SELECT 30
  )
  INSERT INTO x1 
  SELECT NULL, b.x, c.x, d.x 
  FROM dval AS a, dval AS b, dval AS c, dval AS d
  ORDER BY b.x, c.x, d.x
} {wal}

set START -9223372036854775808
set END    9223372036854775807

foreach {tn sql reads sorted} {
  1 {
    SELECT * FROM x1 WHERE a IN (55, 65)
  } {
    2 read 55 55
    2 read 65 65
  } {}

  2 {
    SELECT max(a) FROM x1
  } {
    2 read 81 $END
  } {}

  3 {
    SELECT min(a) FROM x1
  } {
    2 read $START 1
  } {}

  4 {
    SELECT * FROM x1 WHERE a BETWEEN 12 AND 60
  } {
    2 read 12 61
  } {}

  5 {
    SELECT * FROM x1 WHERE a BETWEEN 12 AND 60 ORDER BY a DESC
  } {
    2 read 11 60
  } {}

  6 {
    SELECT * FROM x1 WHERE a>50
  } {
    2 read 50 $END
  } {}

  7 {
    SELECT * FROM x1 WHERE a BETWEEN 10 AND 20;
    SELECT * FROM x1 WHERE a BETWEEN 20 AND 30;
  } {
    2 read 10 21
    2 read 20 31
  } {
    2 read 10 31
  }

  8 {
    SELECT * FROM x1 WHERE a BETWEEN 10 AND 20;
    SELECT * FROM x1 WHERE a BETWEEN 21 AND 30;
  } {
    2 read 10 21
    2 read 21 31
  } {
    2 read 10 31
  }

  9 {
    SELECT * FROM x1 WHERE a BETWEEN 10 AND 20;
    SELECT * FROM x1 WHERE a BETWEEN 22 AND 30;
  } {
    2 read 10 21
    2 read 22 31
  } {
    2 read 10 31
  }

  10 {
    SELECT * FROM x1 WHERE a = 10;
    SELECT * FROM x1 WHERE a = 11;
    SELECT * FROM x1 WHERE a = 12;
  } {
    2 read 10 10
    2 read 11 11
    2 read 12 12
  } {
    2 read 10 12
  }

  11 {
    SELECT * FROM x1;
    SELECT * FROM x1 WHERE a = 11;
    SELECT * FROM x1 WHERE a = 12;
  } {
    2 read $START $END
    2 read 11 11
    2 read 12 12
  } {
    2 read $START $END
  }

  12 {
    SELECT a FROM x1 WHERE b = 10
  } {
    3 read (10)- (10)+
  } {}

  13 {
    SELECT a FROM x1 WHERE b = 12 ORDER BY c DESC
  } {
    3 read (12)- (12)+
  } {}

  14 {
    SELECT a FROM x1 WHERE b = 10;
    SELECT a FROM x1 WHERE b = 10 AND c = 20;
  } {
    3 read (10)- (10)+ 
    3 read (10,20)- (10,20)+
  } {
    3 read (10)- (10)+ 
  }

  15 {
    SELECT a FROM x1 WHERE b = 30 AND c = 20;
    SELECT a FROM x1 WHERE b = 20 AND c = 20;
    SELECT a FROM x1 WHERE b = 10 AND c = 20;
  } {
    3 read (30,20)- (30,20)+
    3 read (20,20)- (20,20)+
    3 read (10,20)- (10,20)+
  } {
    3 read (10,20)- (10,20)+
    3 read (20,20)- (20,20)+
    3 read (30,20)- (30,20)+
  }

  16 {
    SELECT a FROM x1 WHERE b > 10;
  } {
    3 read (10)+ ()+
  } {}

  17 {
    SELECT a FROM x1 WHERE b > 10;
    SELECT a FROM x1 WHERE b = 10;
  } {
    3 read (10)+ ()+
    3 read (10)- (10)+
  } {
    3 read (10)- ()+
  }

  18 {
    SELECT a FROM x1 WHERE b < 10;
    SELECT a FROM x1 WHERE b = 10;
  } {
    3 read (NULL)+ (10,10,10,1)
    3 read (10)- (10)+
  } {
    3 read (NULL)+ (10)+
  }

  19 {
    SELECT count(*) FROM x1
  } {
    4 read ()- ()+
  } {}

  20 {
    SELECT a FROM x1 ORDER BY b
  } {
    3 read ()- ()+
  } {}

  22 {
    SELECT a FROM x1 ORDER BY b DESC
  } {
    3 read ()- ()+
  } {}

  23 {
    SELECT a FROM x1 WHERE (b, c) > (10, 20);
    SELECT a FROM x1 WHERE (b, c) < (10, 20);
  } {
    3 read (10,20)- ()+
    3 read (NULL)+ (10,30,10,19)
  } {
    3 read (NULL)+ ()+
  }

} {
  execsql { BEGIN CONCURRENT }
  execsql $sql

  do_execsql_test 8.$tn.1 {
    SELECT * FROM sqlite_concurrent WHERE op='read'
  } [subst $reads]

  if {[llength $sorted]==0} {
    do_execsql_test 8.$tn.2 {
      SELECT * FROM sqlite_concurrent(1) WHERE op='read'
    } [subst $reads]
  } else {
    do_execsql_test 8.$tn.3 {
      SELECT * FROM sqlite_concurrent(1) WHERE op='read'
    } [subst $sorted]
  }

  execsql { ROLLBACK }
}

#-------------------------------------------------------------------------
reset_db
do_execsql_test 9.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b);
} {wal}

sqlite3 db2 test.db

do_test 9.1 {
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(1, 'one');
      INSERT INTO t1 VALUES(3, 'three');
      INSERT INTO t1 VALUES(5, 'five');
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(2, 'two');
      INSERT INTO t1 VALUES(4, 'four');
      INSERT INTO t1 VALUES(6, 'six');
  } db2

  execsql COMMIT
  execsql COMMIT db2

  execsql {
    SELECT * FROM t1
  }
} {1 one 2 two 3 three 4 four 5 five 6 six}

#-------------------------------------------------------------------------
# Check a few values for SQLITE_CONFIG_SHAREDLOG_MAXSIZE
#
reset_db
db close
catch {db2 close}

foreach {tn val res} {
  1  0       {1 {database is locked}}
  2  10      {1 {database is locked}}
  3  102400  {0 {}}
  4  -1      {0 {}}
} {
  sqlite3_shutdown
  sqlite3_config_sharedlog_maxsize $val

  reset_db
  sqlite3 db2 test.db

  do_test 10.$tn {
    execsql {
      PRAGMA journal_mode = wal;
      CREATE TABLE t1(x INTEGER PRIMARY KEY, y);
      BEGIN CONCURRENT;
        INSERT INTO t1 VALUES(1, 'x');
        INSERT INTO t1 VALUES(10, 'y');
        INSERT INTO t1 VALUES(20, 'z');
    }

    execsql {
      BEGIN CONCURRENT;
        INSERT INTO t1 VALUES(2, 'X');
        INSERT INTO t1 VALUES(11, 'Y');
        INSERT INTO t1 VALUES(21, 'Z');
      COMMIT;
    } db2

    catchsql COMMIT
  } $res

  db close
  db2 close
}

#-------------------------------------------------------------------------
# Test UPDATE statements on WITHOUT ROWID tables.
#
reset_db
do_execsql_test 11.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
  INSERT INTO t1 VALUES(1, 'one');
  INSERT INTO t1 VALUES(2, 'two');

  CREATE TABLE t2(a PRIMARY KEY, b TEXT) WITHOUT ROWID;
  INSERT INTO t2 VALUES(10, 'ten');
  INSERT INTO t2 VALUES(20, 'twenty');
  INSERT INTO t2 VALUES(30, 'thirty');
} {wal}

sqlite3 db2 test.db


do_test 11.1 {
  execsql {
    BEGIN CONCURRENT;
      UPDATE t2 SET b='twenty+1' WHERE a=20;
      SELECT * FROM t1 WHERE a=2;
  }
  execsql {
    BEGIN CONCURRENT;
      UPDATE t1 SET b='one+1' WHERE a=1;
    COMMIT;
  } db2
  execsql {
    COMMIT
  }
} {}

do_execsql_test 11.2 {
  PRAGMA integrity_check;
} ok

#-------------------------------------------------------------------------
#
reset_db
do_execsql_test 12.0 {
  PRAGMA  journal_mode = wal;
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
  CREATE UNIQUE INDEX i1 ON t1(b);
} {wal}

do_execsql_test 12.1 {
  BEGIN CONCURRENT;
    INSERT INTO t1 VALUES(45, 'hello');
    SELECT * FROM sqlite_concurrent;
} {
  2 read 45 45 
  3 read ('hello') ('hello') 
  2 insert 45 (NULL,'hello') 
  3 insert ('hello',45) {}
}
execsql ROLLBACK

#-------------------------------------------------------------------------
# Test that logical retry is not attempted if the transaction wrote
# using an incremental blob handle.
#
db2 close
reset_db
do_execsql_test 13.0 {
  PRAGMA  journal_mode = wal;
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b TEXT);
  CREATE TABLE t2(a INTEGER PRIMARY KEY, b TEXT);
  INSERT INTO t2 VALUES(1, zeroblob(32));
} {wal}

sqlite3 db2 test.db

do_test 13.1.1 {

  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(45, 'hello');
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(46, 'goodbye');
    COMMIT
  } db2

  set fd [db incrblob t2 b 1]
  puts $fd "onetwothree"
  close $fd

  catchsql COMMIT
} {1 {database is locked}}

do_test 13.1.2 { catchsql COMMIT } {1 {database is locked}}
do_test 13.1.3 { catchsql COMMIT } {1 {database is locked}}
execsql ROLLBACK
do_execsql_test 13.1.4 {
  SELECT hex(b) FROM t2
} {0000000000000000000000000000000000000000000000000000000000000000}

do_execsql_test 13.2.1 {
  INSERT INTO t2(b) SELECT b FROM t2;  -- 2
  INSERT INTO t2(b) SELECT b FROM t2;  -- 4
  INSERT INTO t2(b) SELECT b FROM t2;  -- 8
  INSERT INTO t2(b) SELECT b FROM t2;  -- 16
  INSERT INTO t2(b) SELECT b FROM t2;  -- 32
  INSERT INTO t2(b) SELECT b FROM t2;  -- 64
}

do_test 13.2.2 {
  execsql { BEGIN CONCURRENT }

  set fd [db incrblob -readonly t2 b 5]
  read $fd
  close $fd

  set fd [db incrblob -readonly t2 b 64]
  read $fd
  close $fd

  set fd [db incrblob -readonly t2 b 20]
  read $fd
  sqlite3_blob_reopen $fd 25
  read $fd
  sqlite3_blob_reopen $fd 30
  read $fd
  close $fd
} {}
do_execsql_test 13.2.3 {
  SELECT sortem, rowid, * FROM sqlite_concurrent(0)
} {
  {} 0 3 read 5 5 
  {} 0 3 read 64 64 
  {} 0 3 read 20 20
  {} 0 3 read 25 25
  {} 0 3 read 30 30
}
execsql ROLLBACK

#-------------------------------------------------------------------------
# Test that unusual values - reals or zero length texts or blobs - can
# be used in range constraints.
#
reset_db
do_execsql_test 14.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c);
  CREATE INDEX i1bc ON t1(b, c);
  CREATE INDEX i1cb ON t1(c, b);

  INSERT INTO t1 VALUES(-1, 50, 'dog');
  INSERT INTO t1 VALUES(-2, 55, 'cat');
  INSERT INTO t1 VALUES(-3, 60, 'mouse');
  INSERT INTO t1 VALUES(-4, 65, 'rabbit');
  INSERT INTO t1 VALUES(-5, 70, 'hamster');
} {wal}

sqlite3 db2 test.db
do_test 14.1 {
  execsql {
    BEGIN CONCURRENT;
      SELECT * FROM t1 WHERE b>52.5 AND b<66.0;
      INSERT INTO t1 VALUES(0, 45, 'snake');
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(-6, 64, '');
    COMMIT;
  } db2
  catchsql {
    COMMIT;
  }
} {1 {database is locked}}
execsql ROLLBACK

do_test 14.2 {
  execsql {
    BEGIN CONCURRENT;
      SELECT * FROM t1 WHERE c>'';
      INSERT INTO t1 VALUES(0, 45, 'snake');
  }
  execsql {
    BEGIN CONCURRENT;
      INSERT INTO t1 VALUES(-7, 75, 'parrot');
    COMMIT;
  } db2
  catchsql {
    COMMIT;
  }
} {1 {database is locked}}
execsql ROLLBACK

do_execsql_test 14.x.1 {
  BEGIN CONCURRENT;
    DELETE FROM t1 WHERE a=-2;
    SELECT * FROM sqlite_concurrent WHERE op!='read';
} {
  2 delete -2 {} 
  3 delete (55,'cat',254) {} 
  4 delete ('cat',55,254) {}
}
do_execsql_test 14.x.2 {
  SELECT * FROM sqlite_concurrent WHERE sortem IS NOT NULL;
} {}
do_catchsql_test 14.x.3 {
  SELECT * FROM sqlite_concurrent A JOIN sqlite_concurrent B USING (sortem);
} {1 {no query solution}}
execsql ROLLBACK

foreach {tn iVal} {
  1 0
  2 1
  3 500
  4 10000
  5 10000000
  6 1024*1024*1024
  7 -9223372036854775808
  8 9223372036854775807
  9  1000*1024
  10 2147483648
} {
  set iVal [expr $iVal]
  do_test 14.5.$tn {
    execsql {
      BEGIN CONCURRENT;
        SELECT * FROM t1 WHERE b < $iVal ORDER BY b DESC;
    }
    execsql {
      SELECT * FROM sqlite_concurrent;
    }
  } "3 read ()- ($iVal)-"

  execsql ROLLBACK
}



finish_test


